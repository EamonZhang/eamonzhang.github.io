<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>redis on Let&#39;s go 🐌 🐌 🐌</title>
    <link>https://zhangeamon.top/categories/redis/</link>
    <description>Recent content in redis on Let&#39;s go 🐌 🐌 🐌</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 12 Aug 2021 10:44:01 +0800</lastBuildDate><atom:link href="https://zhangeamon.top/categories/redis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>发布订阅</title>
      <link>https://zhangeamon.top/redis/pubsub/</link>
      <pubDate>Thu, 12 Aug 2021 10:44:01 +0800</pubDate>
      
      <guid>https://zhangeamon.top/redis/pubsub/</guid>
      <description>发布订阅 消息多播，一个发布消息可以同时被多个订阅者收听 常用命令 发布 PUBLISH channel message 订阅 SUBSCRIBE channel [channel ...] PSUBSCRIBE pattern [pattern ...] python demo #!/usr/bin/env python import redis import time redis_pool = redis.ConnectionPool(host=&amp;quot;192.168.6.14&amp;quot;,port=&amp;quot;6379&amp;quot;) redis_client = redis.Redis(connection_pool=redis_pool) #生产者 def publishMessages(): while True: redis_client.publish(&amp;quot;channel.shenyang&amp;quot;,&amp;quot;hello news &amp;quot;+time.asctime(time.localtime(time.time()))) time.sleep(2) #消费者 def subscibeMessages(): p = redis_client.pubsub() p.subscribe(&amp;quot;channel.shenyang&amp;quot;) while True: message = p.get_message() if not message: time.sleep(1) continue print(message) #阻塞消费者 def subscibeBlockMessages(): p = redis_client.pubsub() p.subscribe(&amp;quot;channel.shenyang&amp;quot;) for item in p.listen(): print(item[&#39;type&#39;]) if item[&#39;type&#39;] == &#39;message&#39;: print(item[&#39;channel&#39;]) print(item[&#39;data&#39;]) if __name__ == &#39;__main__&#39;: publishMessages() # subscibeMessages() # subscibeBlockMessages() Stream 一个可靠的消息队列 Redis 5.0 引入了</description>
    </item>
    
    <item>
      <title>基于Redis 的分布式锁实现</title>
      <link>https://zhangeamon.top/redis/distributedlock/</link>
      <pubDate>Tue, 10 Aug 2021 15:05:28 +0800</pubDate>
      
      <guid>https://zhangeamon.top/redis/distributedlock/</guid>
      <description>分布式锁场景 秒杀抢购茅台，车票 提前预约抢订车位，共享单车 特点，多个用户同一时间对同一个资源进行申请，并且只能允许一个用户申请成功。 分布式锁必要条件 布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； 高可用的获取锁与释放锁； 高性能的获取锁与释放锁； 具备可重入特性； 具备锁</description>
    </item>
    
    <item>
      <title>Redis 应用场景</title>
      <link>https://zhangeamon.top/redis/redis-scence/</link>
      <pubDate>Tue, 09 Mar 2021 17:23:59 +0800</pubDate>
      
      <guid>https://zhangeamon.top/redis/redis-scence/</guid>
      <description>应用场景 作为一名匠人，当熟悉手里各样工具的特点。用起来才能得心应手。什么时候使用锯子，什么时候当用斧子。 同理熟知产品的技术特性，方可灵活运用。 在面对不同的业务需求时才能提供具有针对性的解决方案。 不求十八般兵器样样精通，但求不置斧锯于一旁只顾轮打锤。 Redis 都能干点啥 缓存 消息队列 循环列表</description>
    </item>
    
    <item>
      <title>Redis 持久化策略</title>
      <link>https://zhangeamon.top/redis/redis-durability/</link>
      <pubDate>Tue, 09 Mar 2021 17:04:58 +0800</pubDate>
      
      <guid>https://zhangeamon.top/redis/redis-durability/</guid>
      <description>持久化的两种方式 RDB 快照 AOF 日志 RDB 快照 快照一次全量备份。 特点： 保存时比较耗系统资源容易造成业务卡顿，恢复比较快。 原理： 使用操作系统的多进程COW(COPY ON Write)机制来实现快照持久化 命令： 堵塞 save ，非堵塞后台执行 bgsave 配置： save m n #配置快照(rdb)促发规则，格式：save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt; #save 900 1</description>
    </item>
    
  </channel>
</rss>
