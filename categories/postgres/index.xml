<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>postgres on 故乡的云☁️</title>
    <link>https://zhangeamon.top/categories/postgres/</link>
    <description>Recent content in postgres on 故乡的云☁️</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 23 Mar 2021 16:32:14 +0800</lastBuildDate><atom:link href="https://zhangeamon.top/categories/postgres/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据库高可用设计分析</title>
      <link>https://zhangeamon.top/postgres/ha_fd/</link>
      <pubDate>Tue, 23 Mar 2021 16:32:14 +0800</pubDate>
      
      <guid>https://zhangeamon.top/postgres/ha_fd/</guid>
      <description>基本概念 集群： 一组多个同时对外提供相同服务的实体机组成一个集群。这里的集群为主从结构，可写节点为主节点，其他只读节点为从节点。 高可用： 在发生局部故障时对整体业务影响很低。即不可用的时间要尽量的短。 对外部应用的访问来说，无需关注如何实现，如同只访问一个节点。并能得到持续的服务能力。</description>
    </item>
    
    <item>
      <title>数据库优化思考-性能优化</title>
      <link>https://zhangeamon.top/postgres/thinking_in_db_performance/</link>
      <pubDate>Fri, 26 Feb 2021 13:33:23 +0800</pubDate>
      
      <guid>https://zhangeamon.top/postgres/thinking_in_db_performance/</guid>
      <description>为什么要优化 首先了解一个概念，什么是·熵增· 物理定义：熵增过程是一个自发的由有序向无序发展的过程(Bortz, 1986; Roth, 1993) 在一个孤立的系统里，如果没有外力做工，其总混乱度（即熵）会不断增大，直至系统彻底变得无序 从系统软件的角度： 从应用系统上线那一刻开始，随着用户量的增加、业务功能的持续</description>
    </item>
    
    <item>
      <title>数据库优化思考 - 模块调优</title>
      <link>https://zhangeamon.top/postgres/thinking_in_db_tune/</link>
      <pubDate>Wed, 13 Jan 2021 09:04:35 +0800</pubDate>
      
      <guid>https://zhangeamon.top/postgres/thinking_in_db_tune/</guid>
      <description>开始乱说 主要是结合postgres数据库自身特点，根据具体的业务场景，作出相应调整，使其更加合理。 数据库作为一个整体对外提供服务，单是其内部是由不同的功能模块组成，相互协调来共同完成任务。 各个功能模块完成不同的功能，每个模块的特点也不同，在调整的时候至少需要理解各个模块实现的基本</description>
    </item>
    
    <item>
      <title>数据库优化思考 - 结构设计</title>
      <link>https://zhangeamon.top/postgres/thinking_in_db_fd/</link>
      <pubDate>Mon, 11 Jan 2021 10:10:42 +0800</pubDate>
      
      <guid>https://zhangeamon.top/postgres/thinking_in_db_fd/</guid>
      <description>DB 与 APP 的不同 有无状态 无状态应用，每个实例提供的服务都是等价、对等的。APP 应用为无状态应用，DB应用为有状态应用。 数据库正是因为有状态，所以维护起来更有挑战。 APP 在面对大量高并发请求时可以无所顾及的增加实例，加机器进行扩容。处理能里也会将得到线性提升。简单粗暴又有效。 DB 面对同样的压</description>
    </item>
    
    <item>
      <title>checkpoint 检查点</title>
      <link>https://zhangeamon.top/postgres/checkpoint/</link>
      <pubDate>Wed, 13 Mar 2019 15:57:25 +0800</pubDate>
      
      <guid>https://zhangeamon.top/postgres/checkpoint/</guid>
      <description>作用 一般checkpoint会将某个时间点之前的脏数据全部刷新到磁盘，以实现数据的一致性与完整性。其主要目的是为了缩短崩溃恢复时间。 触发 超级用户（其他用户不可）执行CHECKPOINT命令 数据库shutdown 数据库recovery完成 XLOG日志量达到了触发checkpoint</description>
    </item>
    
    <item>
      <title>PG主从切换 pg_rewind</title>
      <link>https://zhangeamon.top/postgres/pg_rewind/</link>
      <pubDate>Wed, 30 Jan 2019 10:16:17 +0800</pubDate>
      
      <guid>https://zhangeamon.top/postgres/pg_rewind/</guid>
      <description>pg_rewind requires that the target server either has the wal_log_hints option enabled in postgresql.conf or data checksums enabled when the cluster was initialized with initdb. Neither of these are currently on by default. full_page_writes must also be set to on, but is enabled by default. wal_log_hints 使用场景 在数据库主从结构中，从变成主易。但是由主变为从却需要一番周折。 如果是数据量少时重新使用pg_backup拉一份从即可，但是如果数据量大时，这个过程非常的耗时耗能。对线上业务也会有影</description>
    </item>
    
    <item>
      <title>PG高可用Patroni</title>
      <link>https://zhangeamon.top/postgres/patroni/</link>
      <pubDate>Wed, 30 Jan 2019 10:14:55 +0800</pubDate>
      
      <guid>https://zhangeamon.top/postgres/patroni/</guid>
      <description>环境 操作系统 Centos 7 patroni 版本 2.0.2 postgres 版本 13 实现目标 高可用方案对比 patroni 结构分析 patroni 搭建新集群 patroni 接管现有集群 patroni 管理pg配置 手动swithover 自动failover 维护模式 弹性扩容，缩容 对外提供统一服务 RestFULLAPI 备份恢复 监控 日志 升级 高可用方案对比 pg的高可用方案都是基于流复制来实现 PAF pacemaker + corosyns repmgr repmgr 手动流复制管</description>
    </item>
    
    <item>
      <title>Explain 执行计划</title>
      <link>https://zhangeamon.top/postgres/explain/</link>
      <pubDate>Wed, 05 Dec 2018 15:27:30 +0800</pubDate>
      
      <guid>https://zhangeamon.top/postgres/explain/</guid>
      <description>文法 EXPLAIN [ ( option [, ...] ) ] statement EXPLAIN [ ANALYZE ] [ VERBOSE ] statement 这里 option可以是： ANALYZE [ boolean ] VERBOSE [ boolean ] COSTS [ boolean ] BUFFERS [ boolean ] TIMING [ boolean ] SUMMARY [ boolean ] FORMAT { TEXT | XML | JSON | YAML } 注意事项 记住当使用了ANALYZE选项时语句会被实际执行. 如执行dml 时将对数据库进行实际的操作。 避免污染数据的方式 BEGIN; EXPLAIN ANALYZE ...; ROLLBACK; 一个例子 postgres=# explain analyze select * from tbl; QUERY</description>
    </item>
    
    <item>
      <title>数据库参数</title>
      <link>https://zhangeamon.top/postgres/params/</link>
      <pubDate>Tue, 27 Nov 2018 09:57:27 +0800</pubDate>
      
      <guid>https://zhangeamon.top/postgres/params/</guid>
      <description>性能参数 pgtune pgconfig 日志参数 更多参数详解 管理 listen_addresses = &amp;quot;*&amp;quot; # 连接访问控制，哪些ip可以访问， * 全部。 结合pg_hba.conf , iptables设置。 superuser_reserved_connections = 3 # 预留给超级管理员的连接数。 port = 5432 # 默认访问端口 wal_keep_segments = 1024 # wal 日志保存数量 wal日志 wal_log_hints = on full_page_writes = on 成本因子 # - Planner Cost Constants - #seq_page_cost = 1.0 # measured on an arbitrary scale 顺序扫描 random_page_cost</description>
    </item>
    
    <item>
      <title>主从流复制</title>
      <link>https://zhangeamon.top/postgres/replication01/</link>
      <pubDate>Wed, 17 Oct 2018 14:55:38 +0800</pubDate>
      
      <guid>https://zhangeamon.top/postgres/replication01/</guid>
      <description>历史演变 replication 主库配置 根据实际情况分配流复制权限 vi pg_hba.conf host replication all 10.2.0.0/0 trust vi postgresql.conf max_wal_senders = 10 wal_level = logical # minimal, replica, or logical hot_standby = on # 正常在从库配置，如果在主库配置完毕，因为从库复制主库配置不需要再修改从库配置。 wal_log_hints = on 从库配置 数据库安装 从主库复制数据 pg_basebackup -h 10.2.0.14 -U postgres -F p -P -R -D /var/lib/pgsql/10/data/ --checkpoint=fast -l postgresback20181219 pg_basebackup支持两种全量备份的</description>
    </item>
    
  </channel>
</rss>
